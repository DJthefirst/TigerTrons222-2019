package frc.robot.commands;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Robot;

import com.revrobotics.CANEncoder;

import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;

import jaci.pathfinder.Pathfinder;
import jaci.pathfinder.Trajectory;
import jaci.pathfinder.Waypoint;
import jaci.pathfinder.followers.EncoderFollower;
import jaci.pathfinder.modifiers.TankModifier;

public class DriveLimeLight_4 extends Command {
 
    private CANEncoder driveEncoderLeft = Robot.m_drivetrain.getDriveEncoderLeft();
    private CANEncoder driveEncoderRight = Robot.m_drivetrain.getDriveEncoderRight();
    private AnalogGyro gyro = Robot.m_drivetrain.getDriveGyro();

    double Areval;
    double Distance;
    double TurnAngle;

    double wheelDiameter = .6375;//ft      
    double tickPerRev = 26.66;         //Fix this!!!!!!!!!!
    double maxVelos = 7.4;        //ft
    double maxAccel = 4;        //ft
    double maxJerk = 30000;        //ft
    double wheelBaseWidth = 1.937;  //ft

    Waypoint[] points = new Waypoint[] {
        //new Waypoint(Xcord, Ycord, Pathfinder.d2r(0)),      //Need to fix angle
        new Waypoint(0, 0, Pathfinder.d2r(0)),
        new Waypoint(14, 6, Pathfinder.d2r(0)),
        //new Waypoint(6, 4, Pathfinder.d2r(0))
    };

    Trajectory.Config config = new Trajectory.Config(Trajectory.FitMethod.HERMITE_CUBIC, Trajectory.Config.SAMPLES_HIGH, 0.05, maxVelos, maxAccel, maxJerk);
    Trajectory trajectory = Pathfinder.generate(points, config);
    TankModifier modifier = new TankModifier(trajectory).modify(wheelBaseWidth);

    EncoderFollower left = new EncoderFollower(modifier.getLeftTrajectory());
    EncoderFollower right= new EncoderFollower(modifier.getRightTrajectory());


    public DriveLimeLight_4()
    {
        requires(Robot.m_drivetrain);
    }

    @Override 
    protected void initialize()
    {
        gyro.reset();
        Robot.m_drivetrain.ResetEncoder();

        left.configureEncoder((int) Math.round(driveEncoderLeft.getPosition()), (int) Math.round(tickPerRev), wheelDiameter); //Configure the encoder
		left.configurePIDVA(1.0, 0.0, 0.0, 1 / maxVelos, 0); //Configure the pidva
		right.configureEncoder((int) Math.round(driveEncoderRight.getPosition()), (int) Math.round(tickPerRev), wheelDiameter);
		right.configurePIDVA(1.0, 0.0, 0.0, 1 / maxVelos, 0);
    }

    @Override 
    protected void execute()
    {

       if (!left.isFinished()) {
        //Calculate using the new encoder values
        double l = left.calculate((int) Math.round(driveEncoderLeft.getPosition()));
        double r = right.calculate((int) Math.round(driveEncoderRight.getPosition()));

        //Calculate turning
        double gyro_heading = gyro.getAngle();
        double desired_heading = Pathfinder.r2d(left.getHeading());
        double angleDifference = Pathfinder.boundHalfDegrees(desired_heading - gyro_heading);
        double turn = 0.8 * (-1.0/80.0) * angleDifference;
        
        System.out.println("Left: " +  (l + turn) + ", Right: " + (r - turn) + " Angle: " + gyro.getAngle() + "");

        SmartDashboard.putNumber("Test Left", l);
        SmartDashboard.putNumber("Test RIght", r);

        Robot.m_drivetrain.PathDrive(l + turn,r - turn);

    } else {
        Robot.m_drivetrain.PathDrive(0,0);
    }
}

    @Override 
    protected boolean isFinished()
    {
        return false;
    }



    @Override 
    protected void end(){       
        Robot.m_drivetrain.arcadeDrive(0,0);
    }

    @Override 
    protected void interrupted()
    {
        end();
    }
}