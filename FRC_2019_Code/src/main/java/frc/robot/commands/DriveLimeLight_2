package frc.robot.commands;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Robot;

import com.revrobotics.CANEncoder;

import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;

import jaci.pathfinder.Pathfinder;
import jaci.pathfinder.Trajectory;
import jaci.pathfinder.Waypoint;
import jaci.pathfinder.followers.EncoderFollower;
import jaci.pathfinder.modifiers.TankModifier;

public class DriveLimeLight_2 extends Command {
 
    private CANEncoder driveEncoderLeft = Robot.m_drivetrain.getDriveEncoderLeft();
    private CANEncoder driveEncoderRight = Robot.m_drivetrain.getDriveEncoderRight();
    private AnalogGyro gyro = Robot.m_drivetrain.getDriveGyro();

    double Areval;
    double Distance;
    double TurnAngle;

    double wheelDiameter = .6375;//ft      
    double tickPerRev = 5000;          //Fix this!!!!!!!!!!
    double maxVelos = 4;        //ft
    double maxAccel = 4;        //ft
    double maxJerk = 15;        //ft
    double wheelBaseWidth = 2;  //ft

    double xx;
    double yy;
    double Are;
    double ts;

    NetworkTable table = NetworkTableInstance.getDefault().getTable("limelight");
    NetworkTableEntry tx = table.getEntry("tx");
    NetworkTableEntry ty = table.getEntry("ty");
    NetworkTableEntry ta = table.getEntry("ta");
    NetworkTableEntry Ts= table.getEntry("ts0");

    EncoderFollower left;
    EncoderFollower right;

    public DriveLimeLight_2()
    {
        requires(Robot.m_drivetrain);
    }

    @Override 
    protected void initialize()
    {
        //read values 
        xx = tx.getDouble(0.0);
        yy = ty.getDouble(0.0);
        Are = ta.getDouble(0.0);
        ts = Ts.getDouble(0.0);

        gyro.reset();
        Robot.m_drivetrain.ResetEncoder();

        Distance =(Math.pow(78,(0.092*(yy/1.78+8))))+43;

        SmartDashboard.putNumber("LimelightX", xx);
        SmartDashboard.putNumber("LimelightY", yy);
        SmartDashboard.putNumber("LimelightArea", Are);
        SmartDashboard.putNumber("LimelightDist", Distance);

        double Xcord = Math.sin(ts)*Distance;
        double Ycord = Math.cos(ts)*Distance;

        Waypoint[] points = new Waypoint[] {
            //new Waypoint(Xcord, Ycord, Pathfinder.d2r(0)),      //Need to fix angle
            new Waypoint(5, 5, 0),
            new Waypoint(0, 0, 0)
        };
    
        Trajectory.Config config = new Trajectory.Config(Trajectory.FitMethod.HERMITE_CUBIC, Trajectory.Config.SAMPLES_HIGH, 0.05, maxVelos, maxAccel, maxJerk);
        Trajectory trajectory = Pathfinder.generate(points, config);
        TankModifier modifier = new TankModifier(trajectory).modify(wheelBaseWidth);

        EncoderFollower left = new EncoderFollower(modifier.getLeftTrajectory());
        EncoderFollower right= new EncoderFollower(modifier.getRightTrajectory());

        left.configureEncoder((int) Math.round(driveEncoderLeft.getPosition()), (int) Math.round(tickPerRev), wheelDiameter); //Configure the encoder
		left.configurePIDVA(1.0, 0.0, 0.0, 1 / maxVelos, 0); //Configure the pidva
		right.configureEncoder((int) Math.round(driveEncoderRight.getPosition()), (int) Math.round(tickPerRev), wheelDiameter);
		right.configurePIDVA(1.0, 0.0, 0.0, 1 / maxVelos, 0);
    }

    @Override 
    protected void execute()
    {
       // gyro.getAngle();
       // driveEncoderLeft.getPosition();


       if (!left.isFinished()) {
        //Calculate using the new encoder values
        double l = left.calculate((int) Math.round(driveEncoderLeft.getPosition()));
        double r = right.calculate((int) Math.round(driveEncoderRight.getPosition()));

        //Calculate turning
        double gyro_heading = gyro.getAngle();
        double desired_heading = Pathfinder.r2d(left.getHeading());
        double angleDifference = Pathfinder.boundHalfDegrees(desired_heading - gyro_heading);
        double turn = 0.8 * (-1.0/80.0) * angleDifference;
        
        System.out.println("Left: " +  (l + turn) + ", Right: " + (r - turn) + " Angle: " + gyro.getAngle() + "");
        
        Robot.m_drivetrain.PathDrive(l + turn,r - turn);

    } else {
        Robot.m_drivetrain.PathDrive(0,0);
    }
}

    @Override 
    protected boolean isFinished()
    {
        return false;
    }



    @Override 
    protected void end(){       
        Robot.m_drivetrain.arcadeDrive(0,0);
    }

    @Override 
    protected void interrupted()
    {
        end();
    }
}